// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const createFiles = `-- name: CreateFiles :one
INSERT INTO files (
  fileid, fileuri, filethumbnailuri
) VALUES (
  $1, $2, $3
)
RETURNING fileid, fileuri, filethumbnailuri
`

type CreateFilesParams struct {
	Fileid           string
	Fileuri          string
	Filethumbnailuri string
}

func (q *Queries) CreateFiles(ctx context.Context, arg CreateFilesParams) (File, error) {
	row := q.db.QueryRow(ctx, createFiles, arg.Fileid, arg.Fileuri, arg.Filethumbnailuri)
	var i File
	err := row.Scan(&i.Fileid, &i.Fileuri, &i.Filethumbnailuri)
	return i, err
}

const deleteFiles = `-- name: DeleteFiles :exec
DELETE FROM files
WHERE fileid = $1
`

func (q *Queries) DeleteFiles(ctx context.Context, fileid string) error {
	_, err := q.db.Exec(ctx, deleteFiles, fileid)
	return err
}

const getFiles = `-- name: GetFiles :one
SELECT fileid, fileuri, filethumbnailuri FROM files
WHERE fileid = $1 LIMIT 1
`

func (q *Queries) GetFiles(ctx context.Context, fileid string) (File, error) {
	row := q.db.QueryRow(ctx, getFiles, fileid)
	var i File
	err := row.Scan(&i.Fileid, &i.Fileuri, &i.Filethumbnailuri)
	return i, err
}

const listFiles = `-- name: ListFiles :many
SELECT fileid, fileuri, filethumbnailuri FROM files
`

func (q *Queries) ListFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.Query(ctx, listFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(&i.Fileid, &i.Fileuri, &i.Filethumbnailuri); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
