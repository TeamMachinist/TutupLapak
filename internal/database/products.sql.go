// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const checkProductOwnership = `-- name: CheckProductOwnership :one
SELECT EXISTS(
    SELECT 1 FROM products
    WHERE id = $1::uuid AND user_id = $2::uuid
) as exists
`

type CheckProductOwnershipParams struct {
	ProductID uuid.UUID `json:"product_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckProductOwnership(ctx context.Context, arg CheckProductOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProductOwnership, arg.ProductID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSKUExistsByUser = `-- name: CheckSKUExistsByUser :one
SELECT id, sku
FROM products
WHERE sku = $1::text AND user_id = $2::uuid
LIMIT 1
`

type CheckSKUExistsByUserParams struct {
	Sku    string    `json:"sku"`
	UserID uuid.UUID `json:"user_id"`
}

type CheckSKUExistsByUserRow struct {
	ID  uuid.UUID `json:"id"`
	Sku string    `json:"sku"`
}

func (q *Queries) CheckSKUExistsByUser(ctx context.Context, arg CheckSKUExistsByUserParams) (CheckSKUExistsByUserRow, error) {
	row := q.db.QueryRow(ctx, checkSKUExistsByUser, arg.Sku, arg.UserID)
	var i CheckSKUExistsByUserRow
	err := row.Scan(&i.ID, &i.Sku)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    id,
    name,
    category,
    qty,
    price,
    sku,
    file_id,
    user_id,
    created_at,
    updated_at
) VALUES (
    $1::uuid,
    $2::text,
    $3::text,
    $4,             
    $5,     
    $6::text,
    $7::uuid,
    $8::uuid,
    $9,
    $10
)
RETURNING id, name, category, qty, price, sku, user_id, file_id, created_at, updated_at
`

type CreateProductParams struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Qty       int       `json:"qty"`
	Price     int       `json:"price"`
	Sku       string    `json:"sku"`
	FileID    uuid.UUID `json:"file_id"`
	UserID    uuid.UUID `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Products, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.Category,
		arg.Qty,
		arg.Price,
		arg.Sku,
		arg.FileID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Qty,
		&i.Price,
		&i.Sku,
		&i.UserID,
		&i.FileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1::uuid AND user_id = $2::uuid
`

type DeleteProductParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.UserID)
	return err
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT 
    p.id,
    p.name,
    p.category,
    p.qty,
    p.price,
    p.sku,
    p.file_id,
    p.user_id,
    p.created_at,
    p.updated_at
FROM products p
WHERE 
    p.id = COALESCE(NULLIF($1::uuid, '00000000-0000-0000-0000-000000000000'::uuid), p.id)
    AND p.sku = COALESCE(NULLIF($2::text, ''), p.sku)
    AND p.category = COALESCE(NULLIF($3::text, ''), p.category)
ORDER BY 
    CASE WHEN $4::text = 'newest' THEN GREATEST(p.created_at, p.updated_at) END DESC,
    CASE WHEN $4::text = 'oldest' THEN GREATEST(p.created_at, p.updated_at) END ASC,
    CASE WHEN $4::text = 'cheapest' THEN p.price END ASC,
    CASE WHEN $4::text = 'expensive' THEN p.price END DESC,
    p.created_at DESC
LIMIT COALESCE($6::int, 5)
OFFSET COALESCE($5::int, 0)
`

type GetAllProductsParams struct {
	ProductID   uuid.UUID `json:"product_id"`
	Sku         string    `json:"sku"`
	Category    string    `json:"category"`
	SortBy      string    `json:"sort_by"`
	OffsetCount int       `json:"offset_count"`
	LimitCount  int       `json:"limit_count"`
}

type GetAllProductsRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Qty       int       `json:"qty"`
	Price     int       `json:"price"`
	Sku       string    `json:"sku"`
	FileID    uuid.UUID `json:"file_id"`
	UserID    uuid.UUID `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetAllProducts(ctx context.Context, arg GetAllProductsParams) ([]GetAllProductsRow, error) {
	rows, err := q.db.Query(ctx, getAllProducts,
		arg.ProductID,
		arg.Sku,
		arg.Category,
		arg.SortBy,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProductsRow{}
	for rows.Next() {
		var i GetAllProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Qty,
			&i.Price,
			&i.Sku,
			&i.FileID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT 
    id,
    name,
    category,
    qty,
    price,
    sku,
    file_id,
    user_id,
    created_at,
    updated_at
FROM products 
WHERE id = $1
`

type GetProductByIDRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Qty       int       `json:"qty"`
	Price     int       `json:"price"`
	Sku       string    `json:"sku"`
	FileID    uuid.UUID `json:"file_id"`
	UserID    uuid.UUID `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Qty,
		&i.Price,
		&i.Sku,
		&i.FileID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET
    name = COALESCE(NULLIF($1::text, ''), name),
    category = COALESCE(NULLIF($2::text, ''), category),
    qty = COALESCE($3, qty),
    price = COALESCE($4, price),
    sku = COALESCE(NULLIF($5::text, ''), sku),
    file_id = COALESCE(NULLIF($6::uuid, '00000000-0000-0000-0000-000000000000'::uuid), file_id),
    updated_at = $7
WHERE id = $8::uuid
RETURNING id, name, category, qty, price, sku, file_id, created_at, updated_at
`

type UpdateProductParams struct {
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Qty       int       `json:"qty"`
	Price     int       `json:"price"`
	Sku       string    `json:"sku"`
	FileID    uuid.UUID `json:"file_id"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        uuid.UUID `json:"id"`
}

type UpdateProductRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Qty       int       `json:"qty"`
	Price     int       `json:"price"`
	Sku       string    `json:"sku"`
	FileID    uuid.UUID `json:"file_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (UpdateProductRow, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Category,
		arg.Qty,
		arg.Price,
		arg.Sku,
		arg.FileID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i UpdateProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Qty,
		&i.Price,
		&i.Sku,
		&i.FileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductQty = `-- name: UpdateProductQty :execrows
UPDATE products 
SET qty = qty - $2 
WHERE id = $1
`

type UpdateProductQtyParams struct {
	ID  uuid.UUID `json:"id"`
	Qty int       `json:"qty"`
}

func (q *Queries) UpdateProductQty(ctx context.Context, arg UpdateProductQtyParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProductQty, arg.ID, arg.Qty)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
